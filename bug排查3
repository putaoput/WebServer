1.无法通过webbench的压测:准确来说是短连接无法正常相应，
原因是短连接的task()没有被析构，但是如果使用MyEpoll::del,task就会析构两次，所以智能指针的计数肯定有问题.
新发现webbench一开始的时候是读不出数据的，而读不出数据需要readagain,但是因为状态机设置错误，所以没有正确readagain。isError = true;这个时候跳不出循环，所以也无法避免超过次数和读取发生错误时跳出循环。只有需要
keeplive和readagain的需要重置状态，其余均需要析构掉TASk

2.日志文件被删除就无法写入日志

3.程序过一段事件就抽风的bug，时间堆弹出超时任务时，因为修改了task的析构函数，此时已经没有执行从epoll_fd删除超时字符的功能。仍然存在断开连接，服务器就抽风.用gdb调试发现epoll_wait重复触发已经断开的fd。用isof -i（显示socket文件描述符） 4查看，发现myserver有一个连接处于CLOSE_WAIT状态。该状态是因为客户端断开连接之后，服务器端没有调用close(fd)，实际上就是没有正常析构Task，因为close（fd）在task里面。

!!!最后查看代码终于发现，超时重读事件也被reset()了，即添加了计时器之后哦，仍然进行了reset(),这时就把超时重读事件设置为了0，所以才会出现again_time = 1, 然后又等于0.取消这个reset()之后，就不会发生在客户端关闭连接之后，epoll_wait()会触发，然后发现超时也读不出东西，然后从epoll_fd中删除该fd，然后关闭该fd，结束了close_wait()状态
